export nowAssign = {
  meta: {
    docs: {
      description: "Detect missing 'now' in assignments"
      category: "Possible Errors"
    }
    fixable: false
    schema: []
  }
  create(context) -> {
    AssignmentExpression(node): void -> {
      // Don't enforce `now` with MemberExprs
      if node.left.type == "MemberExpression" or node.left.type == "OptionalMemberExpression": return

      if not node.isNowAssign:
        context.report({
          node
          message: "Incorrect assignment. To reassign, use `now`. To assign as `const`, put on a separate line."
        })
    }
  }
}

isImplicitConstDecl(node) ->
  node.kind == "const" and
  node.extra?.implicit

isImmutableDef(def) ->
  def.type == "FunctionName" or
  def.type == "ClassName" or
  def.type == "ImportBinding" or
  def.kind == "const"

isImmutableVar(v) ->
  isImmutableDef(v.defs[0])

getShadowedVar(v) ->
  v.scope?.upper?.set.get(v.name)

getShadowedPairs(vs) ->
  [...for elem v in vs:
    sv = v~getShadowedVar()
    if sv: [{ shadow: v, shadowed: sv }]
  ]

checkShadowing(context, node, pairFilter, shadowFixer) ->
  if not node~isImplicitConstDecl(): return

  shadowedPairs = context
    .getDeclaredVariables(node)
    ~getShadowedPairs()
    .filter(pairFilter)

  for elem { shadow, shadowed } in shadowedPairs:
    context.report({
      node: shadow.defs[0]?.name or node
      messageId: "shadow"
      ...if shadowFixer: { fix: shadowFixer(shadow) }
      data: { name: shadow.name }
    })

    // Report shadowee as well
    if shadowed.defs[0]?.name:
      context.report({
        node: shadowed.defs[0]?.name
        messageId: "shadowed"
      })

export shadowsImmutable = {
  meta: {
    docs: {
      description: "Detect implicit 'const' shadowing an immutable binding"
      category: "Possible Errors"
    }
    messages: {
      shadow: "Implicit const '{{ name }}' would shadow an immutable binding from a higher scope. Rename the variable or use explicit 'const' to create a new shadowing variable."
      shadowed: "This declaration is shadowed by an implicit const variable in a lower scope."
    }
    fixable: false
    schema: []
  }
  create(context) -> {
    VariableDeclaration(node): void -> {
      checkShadowing(context, node, (pair) -> pair.shadowed~isImmutableVar())
    }
  }
}

export shadowsMutable = {
  meta: {
    docs: {
      description: "Detect implicit 'const' shadowing a mutable binding"
      category: "Possible Errors"
    }
    messages: {
      shadow: "Implicit const '{{ name }}' would shadow a mutable binding from a higher scope. Use 'now' to assign a new value. Use explicit 'const' to create a new shadowing variable."
      shadowed: "This declaration is shadowed by an implicit const variable in a lower scope."
    }
    fixable: true
    schema: []
  }
  create(context) -> {
    VariableDeclaration(node): void -> {
      checkShadowing(
        context
        node
        filter(pair) -> not pair.shadowed~isImmutableVar()
        makeFixer() ->
          (fixer) -> fixer.insertTextBefore(node, "now ")
      )
    }
  }
}

walkVars(scope, callback): void ->
  for elem v in (scope.variables or []): callback(scope, v)
  for elem s in (scope.childScopes or []): walkVars(s, callback)

findDuplicateDeclarations(scope) ->
  result = []
  walkVars(scope, (s, v) -> if v.defs.length > 1: result.push(v))
  result

isImplicitConstDef(def) ->
  parent = def.parent

  parent and
  def.kind == 'const' and
  parent.type == 'VariableDeclaration' and
  parent.kind == 'const' and
  parent.extra?.implicit


export redeclare = {
  meta: {
    docs: {
      description: "Detect redeclaration of variables"
      category: "Possible Errors"
    }
    messages: {
      immutable: "Invalid redeclaration: '{{ name }}'."
      mutable: "Invalid redeclaration: '{{name}}'."
      mutableImplicitConst: "Implicit const redeclaration of '{{name}}'. To reassign, use 'now'."
      shadowed: "'{{name}}', originally defined here, is illegally shadowed later."
    }
    fixable: false
    schema: []
  }
  create(context) -> {
    // Only run once
    Program(node): void -> {
      scope = context.getScope()
      dupes = scope~findDuplicateDeclarations()
      for elem dupe in dupes:
        [firstDef, ...dupeDefs] = dupe.defs
        context.report({
          node: firstDef.node
          messageId: "shadowed"
          data: { name: firstDef.name.name }
        })
        if firstDef~isImmutableDef():
          for elem dupeDef in dupeDefs:
            context.report({
              node: dupeDef.node
              messageId: "immutable"
              data: { name: dupeDef.name.name }
            })
        else:
          for elem dupeDef in dupeDefs:
            if dupeDef~isImplicitConstDef():
              context.report({
                node: dupeDef.node
                messageId: "mutableImplicitConst"
                data: { name: dupeDef.name.name }
              })
            else:
              context.report({
                node: dupeDef.node
                messageId: "mutable"
                data: { name: dupeDef.name.name }
              })
    }
  }
}
