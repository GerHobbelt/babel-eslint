isImplicitConstDecl(node) ->
  node.type == "VariableDeclaration" and
  node.kind == "const" and
  node.extra?.implicit

isImplicitConstDef(def) ->
  def.parent and (def.parent~isImplicitConstDecl!)

isImmutableDef(def) ->
  def.type == "FunctionName" or
  def.type == "ClassName" or
  def.type == "ImportBinding" or
  def.kind == "const"

isImmutableVar(v) ->
  isImmutableDef(v.defs[0])

// Get the variable from a parent scope that would be shadowed by this one
getShadowedVar(v) ->
  v.scope?.upper?.set.get(v.name)

// Get shadow/shadowed pairs for all variables in the given list
getShadowedPairs(vs) ->
  [...for elem v in vs:
    sv = v~getShadowedVar()
    if sv: [{ shadow: v, shadowed: sv }]
  ]

// Walk all vars in scope and children
walkVars(scope, callback): void ->
  for elem v in (scope.variables or []): callback(scope, v)
  for elem s in (scope.childScopes or []): walkVars(s, callback)

varHasDuplicateDelcaration(v) ->
  // TODO: check when OK to dupe
  v.defs.length > 1

findDuplicateDeclarations(scope) ->
  result = []
  walkVars(scope, (s, v) -> if v~varHasDuplicateDelcaration(): result.push(v))
  result

export default {
  meta: {
    docs: {
      description: "Find errors in variable declaration and assignment"
      category: "Possible Errors"
    }
    messages: {
      notNowAssign: "Incorrect assignment. To reassign, use `now`. To declare a `const` variable, put on a separate line."

      shadowed: "'{{name}}', originally defined here, is illegally shadowed later."

      shadowsImmutableRedef: "'{{name}}' shadows an immutable binding. Rename the variable or use explicit `const` to shadow the existing variable."

      shadowsImmutableNoRedef: "'{{name}}' shadows an immutable binding."

      shadowsMutableRedef: "'{{name}}' shadows a mutable binding. Use `now` to reassign or explicit `const` to shadow the variable."

      shadowsMutableReassign: "'{{name}}' shadows a mutable binding. Use `now` to reassign."

      shadowsMutable: "'{{name}}' shadows a mutable binding."
    }
    fixable: true
    schema: []
  }
  create(context) -> {
    // Check for missing `now` in assignments
    AssignmentExpression(node): void -> {
      // Don't enforce `now` with MemberExprs
      if node.left.type == "MemberExpression" or node.left.type == "OptionalMemberExpression": return

      if not node.isNowAssign:
        context.report({
          node
          messageId: "notNowAssign"
          fix(fixer) -> fixer.insertTextBefore(node, "now ")
        })
    }

    // Check for implicit `const` shadowing declarations
    VariableDeclaration(node): void -> {
      if not node~isImplicitConstDecl(): return

      shadowedPairs = context.getDeclaredVariables(node)~getShadowedPairs()
      for elem { shadowed } in shadowedPairs:
        context.report({
          node: shadowed.defs[0]?.name or node
          messageId: "shadowed"
          data: { name: shadowed.name }
        })

      // If shadowing an immutable variable, must use explicit `const`
      immutablePairs = shadowedPairs.filter(p -> p.shadowed~isImmutableVar())
      for elem { shadow } in immutablePairs:
        context.report({
          node: shadow.defs[0]?.name or node
          messageId: "shadowsImmutableRedef"
          data: { name: shadow.name }
        })

      // If shadowing a mutable variable, can use `now`
      mutablePairs = shadowedPairs.filter(p -> not p.shadowed~isImmutableVar())
      for elem { shadow } in mutablePairs:
        context.report({
          node: shadow.defs[0]?.name or node
          messageId: "shadowsMutableRedef"
          data: { name: shadow.name }
          fix(fixer) -> fixer.insertTextBefore(node, "now ")
        })
    }

    // Check for illegal variable redeclarations in the same scope.
    // Based on Babel's `checkBlockScopedCollisions`
    // Run only once at Program scope
    Program(node): void -> {
      dupes = context.getScope()~findDuplicateDeclarations()
      for elem dupe in dupes:
        [firstDef, ...dupeDefs] = dupe.defs
        context.report({
          node: firstDef.node
          messageId: "shadowed"
          data: { name: firstDef.name.name }
        })
        if firstDef~isImmutableDef():
          for elem dupeDef in dupeDefs:
            context.report({
              node: dupeDef.node
              messageId: "shadowsImmutableNoRedef"
              data: { name: dupeDef.name.name }
            })
        else:
          for elem dupeDef in dupeDefs:
            if dupeDef~isImplicitConstDef():
              context.report({
                node: dupeDef.node
                messageId: "shadowsMutableReassign"
                data: { name: dupeDef.name.name }
                fix(fixer) -> fixer.insertTextBefore(dupeDef.parent, "now ")
              })
            else:
              context.report({
                node: dupeDef.node
                messageId: "shadowsMutable"
                data: { name: dupeDef.name.name }
              })
    }
  }
}
